<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-44644915-1']);
            _gaq.push(['_trackPageview']);

            (function() {
             var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
             ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
             var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
             })();
        </script>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Matthew Hall - Creating models of F1 tracks in Rust - Part 1</title>
        <link rel="stylesheet" type="text/css" href="../css/bootstrap.css" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div class="container">
          <nav class="navbar navbar-fixed-top">
              <div id="logo" class="navbar-header">
                  <a href="../">Matthew Hall</a>
              </div>
              <div id="navigation" class="nav navbar-nav navbar-collapse">
                  <a href="../">Home</a>
                  <a href="../projects.html">Projects</a>
                  <a href="../archive.html">Archive</a>
                  <a href="../about.html">About</a>
              </div>
              <div class="navbar-right marks">
                <a href="https://github.com/mattyhall/"><img src="../images/github_mark.png" /></a>
                <a href="http://twitter.com/hailmattyhall"><img src="../images/twitter_mark.png" /></a>
              </div>
          </nav>
        </div>
        <div id="content" class="container">
            <div class="row">
                <h1>Creating models of F1 tracks in Rust - Part 1</h1>

                <div class="info">
    Posted on 2014-08-19 under <a href="../tags/rust.html">rust</a>, <a href="../tags/programming.html">programming</a>, <a href="../tags/formula1.html">formula1</a>
</div>

<p><strong>DISLAIMER: Compiled with rustc version 0.12.0-pre-nightly (commit 01ec6fab2). Whether it works with later versions is anyone’s guess. I’m only a beginner to Rust so do not think that I know what I’m doing or that my code is idomatic. :)</strong></p>
<p>I’m a massive Formula 1 fan so it won’t surprise those who know about the sport that the past few Sundays have been rather boring. You see it is the mid season break which means three consecutive weekends with no racing. Luckily I found a way to fight the withdrawal symptoms - some F1 themed programming! But what?</p>
<p>Well you can probably guess from the title - 3D models of the tracks - but there is a good reason for it. It is very rare that you get to see all of the track on telly, and if you do then it is usually only a 2D drawing. I thought it would be cool to see how much the track goes up and down. Quite often you will hear a commentator say “The camera image does not do the climb justice” or something to that efffect. Let’s see if they’re right!</p>
<h2 id="why-rust">Why Rust?</h2>
<p>I know how to program in Python - a high level, imperative language - and Haskell - a high level, functional language. I thought it was about time I learnt a systems programming language to complete the set of programming language types I’ve learnt (I’m not going to say “know” as that is probably too grand a term). As I said in the disclaimer this code may not be idiomatic. I’ve tried to be as accurate as possible and I’m happy to be corrected/berated.</p>
<p>For those who don’t know <a href="http://www.rust-lang.org/">Rust</a> is a language with algebraic data types, pattern matching, support for functional programming (for some definition of functional) and safety. It is meant to be used in places where C++ may have been used but unlike C++ you can’t accidently access memory that has been deallocated easily. Be wary though: Rust hasn’t stabalised so it isn’t ready for production.</p>
<p>It could probably be said that this is not a task that Rust will be particularly suited for and it’d be much quicker to do this sort of thing in a scripting language. I decided to ignore this train of thought however because I was worried it was my brain trying to save itself the work of learning a new language. It was actually quite enjoyable in the end.</p>
<h2 id="parsing-osm-files">Parsing OSM files</h2>
<p>So the first thing we need to do is get some data for the track. Luckily <a href="http://openstreetmaps.org/">openstreetmaps.org</a> allow you to download their data in a nice XML format. It’s as easy as searching for the track, eg. “Spa”, drawing a box around the circuit and then clicking “export”. Here’s an example of what the file looks like:</p>
<pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;osm</span><span class="ot"> version=</span><span class="st">&quot;0.6&quot;</span><span class="ot"> generator=</span><span class="st">&quot;CGImap 0.3.3 (32175 thorn-03.openstreetmap.org)&quot;</span><span class="ot"> copyright=</span><span class="st">&quot;OpenStreetMap and contributors&quot;</span><span class="ot"> attribution=</span><span class="st">&quot;http://www.openstreetmap.org/copyright&quot;</span><span class="ot"> license=</span><span class="st">&quot;http://opendatacommons.org/licenses/odbl/1-0/&quot;</span><span class="kw">&gt;</span>
 <span class="kw">&lt;node</span><span class="ot"> id=</span><span class="st">&quot;147753704&quot;</span><span class="ot"> visible=</span><span class="st">&quot;true&quot;</span><span class="ot"> version=</span><span class="st">&quot;1&quot;</span><span class="ot"> changeset=</span><span class="st">&quot;47586&quot;</span><span class="ot"> user=</span><span class="st">&quot;gaku&quot;</span><span class="ot"> lat=</span><span class="st">&quot;50.4226185&quot;</span><span class="ot"> lon=</span><span class="st">&quot;5.9660655&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;tag</span><span class="ot"> k=</span><span class="st">&quot;created_by&quot;</span><span class="ot"> v=</span><span class="st">&quot;JOSM&quot;</span><span class="kw">/&gt;</span>
 <span class="kw">&lt;/node&gt;</span>
 <span class="kw">&lt;way</span><span class="ot"> id=</span><span class="st">&quot;174892450&quot;</span><span class="ot"> visible=</span><span class="st">&quot;true&quot;</span><span class="ot"> version=</span><span class="st">&quot;1&quot;</span><span class="ot"> changeset=</span><span class="st">&quot;12643060&quot;</span><span class="ot"> user=</span><span class="st">&quot;Scrup&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;nd</span><span class="ot"> ref=</span><span class="st">&quot;1855362418&quot;</span><span class="kw">/&gt;</span>
  <span class="kw">&lt;nd</span><span class="ot"> ref=</span><span class="st">&quot;1855362431&quot;</span><span class="kw">/&gt;</span>
 <span class="kw">&lt;/way&gt;</span>
 <span class="kw">&lt;relation</span><span class="ot"> id=</span><span class="st">&quot;284560&quot;</span><span class="ot"> visible=</span><span class="st">&quot;true&quot;</span><span class="ot"> version=</span><span class="st">&quot;11&quot;</span><span class="ot"> changeset=</span><span class="st">&quot;12942711&quot;</span><span class="ot"> user=</span><span class="st">&quot;Scrup&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;member</span><span class="ot"> type=</span><span class="st">&quot;node&quot;</span><span class="ot"> ref=</span><span class="st">&quot;258602622&quot;</span><span class="ot"> role=</span><span class="st">&quot;start&quot;</span><span class="kw">/&gt;</span>
  <span class="kw">&lt;member</span><span class="ot"> type=</span><span class="st">&quot;way&quot;</span><span class="ot"> ref=</span><span class="st">&quot;126807101&quot;</span><span class="ot"> role=</span><span class="st">&quot;&quot;</span><span class="kw">/&gt;</span>
  <span class="kw">&lt;member</span><span class="ot"> type=</span><span class="st">&quot;way&quot;</span><span class="ot"> ref=</span><span class="st">&quot;126807110&quot;</span><span class="ot"> role=</span><span class="st">&quot;&quot;</span><span class="kw">/&gt;</span>
  <span class="kw">&lt;member</span><span class="ot"> type=</span><span class="st">&quot;way&quot;</span><span class="ot"> ref=</span><span class="st">&quot;34403885&quot;</span><span class="ot"> role=</span><span class="st">&quot;pit_lane&quot;</span><span class="kw">/&gt;</span>
  <span class="kw">&lt;tag</span><span class="ot"> k=</span><span class="st">&quot;name&quot;</span><span class="ot"> v=</span><span class="st">&quot;Ciruit de Spa Francorchamps&quot;</span><span class="kw">/&gt;</span>
  <span class="kw">&lt;tag</span><span class="ot"> k=</span><span class="st">&quot;type&quot;</span><span class="ot"> v=</span><span class="st">&quot;circuit&quot;</span><span class="kw">/&gt;</span>
 <span class="kw">&lt;/relation&gt;</span></code></pre>
<p>Relations group together different entities together. Ways are list of nodes. Nodes are a point on Earth. Each may have a number of tags associated with it to store extra information. Our first step should be to write some code which parses this information into a data structure. I didn’t really fancy writing my own XML parser so I looked about for a Rust library (which are called crates) to do so. It turns out there are quite a few including, but not limited to, <a href="https://github.com/netvl/rust-xml">rust-xml</a>, <a href="https://github.com/Florob/RustyXML">RustXML</a> and <a href="https://github.com/bjz/sax-rs">sax-rs</a>.</p>
<p>Before writing this program I had never heard of SAX. I thought all XML parsers turned XML into a DOM (a list of tags which each have their own children and so on). Instead SAX will read “events” from the XML passed in, where an event is something like “Start element with these attributes” or “End element”. I ended up opting for sax-rs but I don’t know if this was the correct choice. When I wrote this it had been updated fairly recently and it compiled but whether it is the best/fasted library for the job I do not know.</p>
<p><strong>EDIT: The author of sax-rs has recommended using <a href="https://github.com/netvl/rust-xml/">netvl/rust-xml</a></strong></p>
<p>Let’s get the imports out of the way first:</p>
<pre class="sourceCode rust"><code class="sourceCode rust">#![feature(struct_variant)]
<span class="kw">extern</span> crate sax;

<span class="kw">use</span> std::collections::HashMap;
<span class="kw">use</span> std::io::IoError;</code></pre>
<p>Let’s create an enum to hold each type of element:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">type</span> Tags = HashMap&lt;String, String&gt;;

<span class="kw">pub</span> <span class="kw">enum</span> OsmElement {
    Node { <span class="kw">pub</span> id: <span class="kw">int</span>, <span class="kw">pub</span> lat: <span class="kw">f64</span>, <span class="kw">pub</span> lng: <span class="kw">f64</span>, <span class="kw">pub</span> visible: <span class="kw">bool</span>, <span class="kw">pub</span> tags: Tags },
    Way { <span class="kw">pub</span> id: <span class="kw">int</span>, <span class="kw">pub</span> nodes: Vec&lt;<span class="kw">int</span>&gt;, <span class="kw">pub</span> tags: Tags },
    Relation { <span class="kw">pub</span> id: <span class="kw">int</span>, <span class="kw">pub</span> members: Vec&lt;<span class="kw">int</span>&gt;, <span class="kw">pub</span> tags: Tags },
}</code></pre>
<p>This is the first example of Algebraic Data Types in Rust. Normally enums in Rust look like this:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">enum</span> OsmElement {
    Node(<span class="kw">int</span>, <span class="kw">f64</span>, <span class="kw">f64</span>, <span class="kw">f64</span>, <span class="kw">bool</span>, Tags),
}</code></pre>
<p>But, <code>struct_variant</code> allows you to give names to the values the enum holds. In this case I wonder if having separate structs (eg Node, Way, Relation) and then having the enum variants store one of those structs would be better.</p>
<p>I decided to store the tags as a hash map of strings. In Rust there are two different string types: <code>String</code> and <code>&amp;str</code>. The former is mutable but allocates memory and the latter is immutable and references another string. As far as I know <code>&amp;str</code> is prefered when possible however sax-rs stores attributes as <code>String</code>s so I shall follow their lead. It also makes writing the code a bit easier (if I used <code>&amp;str</code> I would have to annotate how long it should live).</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> Osm {
    parser: Receiver&lt;sax::ParseResult&gt;,
    <span class="kw">pub</span> elements: HashMap&lt;<span class="kw">int</span>, OsmElement&gt;
}

<span class="kw">impl</span> Osm {
    <span class="kw">pub</span> <span class="kw">fn</span> new(path: &amp;Path) -&gt; Osm {
        <span class="kw">let</span> parser = sax::parse_file(path).unwrap();
        <span class="kw">let</span> <span class="kw">mut</span> s = Osm {parser: parser, elements: HashMap::new()};
        s.parse();
        s
    }
    
    <span class="kw">fn</span> parse(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
        <span class="kw">match</span> <span class="kw">self</span>.parser.recv() {
            <span class="kw">Ok</span>(sax::StartDocument) =&gt; (),
            _ =&gt; <span class="ot">fail!</span>(<span class="st">&quot;Document did not start&quot;</span>)
        }
        ...
    }</code></pre>
<p>We create a struct to store our elements in. The weird <code>Receiver</code> type you see is one of Rust’s channel types. Basically parser is something which we can pull <code>ParseResult</code>s out of. The sax-rs library returns one of these when we call <code>parse_file</code>, wrapped inside an <code>Option</code> which is like <code>Maybe</code> from Haskell. An <code>Option</code> can either have a value <code>Some(T)</code> or be empty <code>None</code> which allows us to give some notion of whether something was successful or not. In this case we call <code>unwrap</code> which will give back the value stored or will stop the program running. This is something that should be avoided unless you know for definite that the <code>Option</code> is a <code>Some</code>.</p>
<p>We then create an <code>Osm</code> and call <code>parse</code>. The <code>&amp;mut self</code> parameter tells us that the <code>parse</code> should be called on an <code>Osm</code> which is mutable. The function gets passed a reference to this <code>Osm</code>. In Rust variables are immutable by default. The first thing <code>parse</code> does is ask the <code>Receiver</code> for a value. We then use pattern matching to see what we got.</p>
<p>We pattern match on a <code>sax::ParseResult</code> which is a special version of the <code>Result</code> type included in the standard library. A result can be either <code>Ok</code> or an <code>Err</code>. If we get a StartDocument value we return <code>()</code> - an empty tuple - and if we get anything else we fail the program with a message. Wouldn’t it be nice though to not just fail though? It’d be better if we reported the error:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>deriving<span class="ot">(</span>Show<span class="ot">)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> OsmParseError {
    IoErr(IoError),
    SaxErr(sax::error::ErrorData),
    ParseErr(String),
}

<span class="co">// not to be confused with sax::ParseResult</span>
<span class="kw">pub</span> <span class="kw">type</span> ParseResult = <span class="kw">Result</span>&lt;(), OsmParseError&gt;;

<span class="kw">impl</span> Osm {
    <span class="kw">pub</span> <span class="kw">fn</span> new(path: &amp;Path) -&gt; <span class="kw">Result</span>&lt;Osm, OsmParseError&gt; {
        <span class="kw">let</span> parser = sax::parse_file(path).unwrap();
        <span class="kw">let</span> <span class="kw">mut</span> s = Osm {parser: parser, elements: HashMap::new()};
        <span class="ot">try!</span>(s.parse());
        <span class="kw">Ok</span>(s)
    }
    
    <span class="kw">fn</span> parse(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; ParseResult {
        <span class="kw">match</span> <span class="kw">self</span>.parser.recv() {
            <span class="kw">Ok</span>(sax::StartDocument) =&gt; (),
            <span class="kw">Ok</span>(e) =&gt; <span class="kw">return</span> <span class="kw">Err</span>(ParseErr(<span class="ot">format!</span>(<span class="st">&quot;Document started with: {}&quot;</span>, e))),
            <span class="kw">Err</span>(e) =&gt; <span class="kw">return</span> <span class="kw">Err</span>(SaxErr(e))
        }

        <span class="kw">for</span> event in <span class="kw">self</span>.parser.iter() {
            <span class="kw">match</span> event {
                <span class="kw">Ok</span>(sax::StartElement(name, attrs)) =&gt; <span class="ot">try!</span>(<span class="kw">self</span>.parse_start_element(name, attrs)),
                <span class="kw">Ok</span>(_) =&gt; (),
                <span class="kw">Err</span>(e) =&gt; <span class="kw">return</span> <span class="kw">Err</span>(SaxErr(e)),
            }
        }
        <span class="kw">Ok</span>(())
    }</code></pre>
<p>First we create an enum to store each type of error we could get. In <code>new</code> we use <code>try!</code> which is a macro. In fact everything with an exclamation mark on the end is a macro (for example <code>fail!</code>). <code>try!</code> will look at the <code>Result</code> it is passed and if it is an <code>Err</code> it will return the current function (in this case <code>new</code>) with that <code>Err</code>. If it is <code>Ok</code> it’ll just give back the value. We end the <code>new</code> function by wrapping it in an <code>Ok</code> so it is a <code>Result</code>.</p>
<p>This time <code>parse</code> will return an error if the document did not start. The <code>iter</code> function on a <code>Receiver</code> returns an iterator which will get a result each time it is asked to. In Rust an iterator is something that has a <code>next</code> method which returns a value in an <code>Option</code> when it is called. If the <code>Option</code> is <code>None</code> and it is being used in a for loop then the for loop stops.</p>
<p>If the event is the start of an element we call <code>parse_start_element</code>, again with the <code>try!</code> macro. Any other event we can ignore as it should be a comment or some text. We return any errors.</p>
<pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">fn</span> parse_start_element(&amp;<span class="kw">mut</span> <span class="kw">self</span>, name: String, attrs: sax::Attributes) -&gt; ParseResult {
        <span class="kw">match</span> name.as_slice() {
            <span class="st">&quot;relation&quot;</span> =&gt; <span class="ot">try!</span>(<span class="kw">self</span>.parse_relation(attrs)),
            <span class="st">&quot;node&quot;</span> =&gt; <span class="ot">try!</span>(<span class="kw">self</span>.parse_node(attrs)),
            <span class="st">&quot;way&quot;</span> =&gt; <span class="ot">try!</span>(<span class="kw">self</span>.parse_way(attrs)),
            _  =&gt; ()
        }
        <span class="kw">Ok</span>(())
    }</code></pre>
<p><code>parse_start_element</code> just calls other methods depending on which element was found. Note that <code>as_slice</code> is called on <code>name</code> because string literals are of type <code>&amp;str</code> and <code>name</code> is a <code>String</code>. Let’s have a look at <code>parse_node</code>:</p>
<pre class="sourceCode rust"><code class="sourceCode rust">    <span class="co">// parses &lt;node id=1 lat=50.23232 lon=0.12121 visible=true&gt;&lt;tag k=&quot;key&quot; v=&quot;val&quot;/&gt;&lt;/node&gt;</span>
    <span class="kw">fn</span> parse_node(&amp;<span class="kw">mut</span> <span class="kw">self</span>, attrs: sax::Attributes) -&gt; ParseResult { 
        <span class="kw">let</span> id = attrs.find(<span class="st">&quot;id&quot;</span>).and_then(|v| from_str(v));
        <span class="kw">let</span> lat = attrs.find(<span class="st">&quot;lat&quot;</span>).and_then(|v| from_str(v));
        <span class="kw">let</span> lng = attrs.find(<span class="st">&quot;lon&quot;</span>).and_then(|v| from_str(v));
        <span class="kw">let</span> visible = attrs.find(<span class="st">&quot;visible&quot;</span>).and_then(|v| from_str(v));
        <span class="kw">let</span> (id, lat, lng, visible) = <span class="kw">match</span> (id, lat, lng, visible) {
            (<span class="kw">Some</span>(id), <span class="kw">Some</span>(lat), <span class="kw">Some</span>(lng), <span class="kw">Some</span>(visible)) =&gt; (id, lat, lng, visible),
            _ =&gt; <span class="kw">return</span> <span class="kw">Err</span>(ParseErr(
                <span class="st">&quot;Could not find all required attributes on node&quot;</span>.to_string()))
        };
        <span class="kw">let</span> <span class="kw">mut</span> tags = HashMap::new();

        <span class="kw">for</span> event in <span class="kw">self</span>.parser.iter() {
            <span class="kw">match</span> event {
                <span class="kw">Ok</span>(sax::StartElement(name, attrs)) =&gt; {
                    <span class="kw">match</span> name.as_slice() {
                        <span class="st">&quot;tag&quot;</span> =&gt; <span class="ot">try!</span>(<span class="kw">self</span>.parse_tag(attrs, &amp;<span class="kw">mut</span> tags)),
                        _ =&gt; <span class="kw">return</span> <span class="kw">Err</span>(ParseErr(<span class="ot">format!</span>(
                              <span class="st">&quot;Expecting all children of nodes to be tags. Got a {}&quot;</span>,
                              name))),
                    }
                }
                <span class="kw">Ok</span>(sax::EndElement(name)) =&gt; {
                    <span class="kw">if</span> name.as_slice() == <span class="st">&quot;node&quot;</span> {
                        <span class="kw">break</span>;
                    }
                    <span class="kw">return</span> <span class="kw">Err</span>(ParseErr(<span class="ot">format!</span>(
                        <span class="st">&quot;Expecting node to end, not a {}&quot;</span>, name)));
                }
                _ =&gt; {},
            }
        }

        <span class="kw">self</span>.elements.insert(id, Node{id: id, lat: lat, lng: lng,
                                      visible: visible, tags: tags});

        <span class="kw">Ok</span>(())
    }</code></pre>
<p>First off we grab all the attributes we want using <code>find</code>. As this may fail we get an <code>Option</code> back. Next we use <code>and_then</code> which is a method that takes a closure (an anonymous function) and calls it with the value if there was one. We use this to convert a string into a Rust data type.</p>
<p>We then iterate through events again. If a tag starts then we parse that and if the node tag ends we stop iterating and insert the node into the elements hash map with it’s id as the key so we can look up specific elements later. Anything else is an error because only tags can be children and the <code>parse_tag</code> function handles ending the tag element.</p>
<p>That was quite a lot of code and I don’t really fancy writing it again. Unfortunately both <code>parse_way</code> and <code>parse_relation</code> are likely to be quite similar as they have to check they get the right children and the element ends. My first thought was to have a function that took a closure which would handle checking the children.</p>
<p>It turns out this is somewhat trickier than I expected due to the fact that Rust only allows one mutable reference at a time, so this function could not be a method on <code>Osm</code>. At the time of writing the code I could not work this out and was baffled, it was only during writing this that I realised how to do it. You can take a look at it <a href="https://gist.github.com/mattyhall/46fafc61c6e0eb1db35c">here</a>.</p>
<p>I ended up asking for a code review on the Rust subreddit. The very helpful Chris Morgan suggested that I used a macro which I adapted slightly to be more general:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> parse {
    ($iter:expr, $close_tag:expr $(, $tag:pat =&gt; $method:expr)*) =&gt; {
        <span class="kw">for</span> event in $iter {
            <span class="kw">match</span> event {
                <span class="kw">Ok</span>(sax::StartElement(name, attrs)) =&gt; {
                    <span class="kw">match</span> name.as_slice() {
                        $($tag =&gt; <span class="ot">try!</span>($method(attrs)),)*
                        _ =&gt; <span class="kw">return</span> <span class="kw">Err</span>(ParseErr(<span class="ot">format!</span>(
                              <span class="st">&quot;Unexpected child in {} Got a {}&quot;</span>,
                              $close_tag, name))),
                    }
                }
                <span class="kw">Ok</span>(sax::EndElement(name)) =&gt; {
                    <span class="kw">if</span> name.as_slice() == $close_tag {
                        <span class="kw">break</span>;
                    }
                    <span class="kw">return</span> <span class="kw">Err</span>(ParseErr(<span class="ot">format!</span>(
                            <span class="st">&quot;Expecting {} to end, not a {}&quot;</span>, 
                            $close_tag, name)));
                }
                _ =&gt; {},
            }
        }
    }
}</code></pre>
<p>The first line defines that this is a macro. We then specify the parameters to the macro which all start with a dollar sign. We have <code>$iter</code> which is an <code>expr</code> or expression. Then is the tag name which we want to close. The last part is a bit more confusing. The <code>$(..)*</code> means match <code>..</code> zero or more times. In this case <code>..</code> is something like <code>&quot;tag&quot; =&gt; |attrs| self.parse_tag(attrs)</code>. Note that <code>$tag</code> is a <code>pat</code> - something we can pattern match on. The body of the macro should look familiar. The only strange bit is <code>$($tag =&gt; try!($method(attrs)),)*</code>. For every value of <code>$tag</code> and <code>$method</code> this will expand to <code>$tag =&gt; try!($method(attrs)),</code>.</p>
<p>The macro is used like so:</p>
<pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">fn</span> parse_relation(&amp;<span class="kw">mut</span> <span class="kw">self</span>, attrs: sax::Attributes) -&gt; ParseResult {
        <span class="kw">let</span> id = <span class="ot">try!</span>(<span class="kw">self</span>.parse_int_attr(<span class="st">&quot;id&quot;</span>, attrs));
        <span class="kw">let</span> <span class="kw">mut</span> tags = HashMap::new();
        <span class="kw">let</span> <span class="kw">mut</span> members = Vec::new();

        <span class="ot">parse!</span>(<span class="kw">self</span>.parser.iter(), <span class="st">&quot;relation&quot;</span>,
               <span class="st">&quot;member&quot;</span> =&gt; |attrs| <span class="kw">Ok</span>(members.push(<span class="ot">try!</span>(<span class="kw">self</span>.parse_member(attrs)))),
               <span class="st">&quot;tag&quot;</span> =&gt; |attrs| <span class="kw">self</span>.parse_tag(attrs, &amp;<span class="kw">mut</span> tags));

        <span class="kw">self</span>.elements.insert(id, Relation{id: id, members: members, tags: tags});
        <span class="kw">Ok</span>(())
    }

    <span class="kw">fn</span> parse_tag(&amp;<span class="kw">mut</span> <span class="kw">self</span>, attrs: sax::Attributes, tags: &amp;<span class="kw">mut</span> Tags) -&gt; ParseResult {
        <span class="kw">let</span> (k, v) = <span class="kw">match</span> (attrs.find_clone(<span class="st">&quot;k&quot;</span>), attrs.find_clone(<span class="st">&quot;v&quot;</span>)) {
            (<span class="kw">Some</span>(k), <span class="kw">Some</span>(v)) =&gt; (k, v),
            _ =&gt; <span class="kw">return</span> <span class="kw">Err</span>(ParseErr(<span class="st">&quot;Tag must have a k and a v attribute&quot;</span>.to_string()))
        };

        <span class="ot">parse!</span>(<span class="kw">self</span>.parser.iter(), <span class="st">&quot;tag&quot;</span>);

        tags.insert(k, v);
        <span class="kw">Ok</span>(())
    }</code></pre>
<p>The rest of the parsing code is quite repetitive so I’ll let you <a href="https://github.com/mattyhall/osmxml">browse it</a> at your own leisure. Feel free to contact me if there is something you don’t understand.</p>
<h2 id="getting-the-points-of-the-track">Getting the points of the track</h2>
<p>I took a lot more space talking about the parser than I expected so I’ll have to leave converting this data into models (the fun bit!) to another blog post. I feel like leaving all of it to the next post is a bit of a cop out so I’ll quickly show you how to get a list of points from an OSM file.</p>
<p>Well, I say a list of points from an OSM file. I actually mean a list of lists of points because two consecutive elements in a way element should be joined up. However this is not true of two consecutive elements in a relation as far as I can tell. This isn’t really important right now but will be in later blog posts.</p>
<p>First you will need to create a project using Cargo, the Rust package manager. If you installed Rust from the website you should also have Cargo installed. Run:</p>
<pre><code>$ cargo new osmmodels
$ cd osmmodels</code></pre>
<p>Then add a dependency to <code>Cargo.toml</code>. This will compile your code with my osm parser:</p>
<pre><code>[dependencies.osmxml]
git = &quot;https://github.com/mattyhall/osmxml&quot;</code></pre>
<p>The following code should go in src/main.rs</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate osmxml;
<span class="kw">use</span> osmxml::{Osm, OsmElement, Relation, Way, Node};

<span class="kw">fn</span> main() {
    <span class="kw">let</span> path = &amp;Path::new(<span class="st">&quot;spa.osm&quot;</span>);
    <span class="kw">let</span> osm = Osm::new(path).unwrap();
    <span class="kw">let</span> relation = osm.elements.values().filter(|e| {
        <span class="kw">match</span> **e {
            Relation{tags: <span class="kw">ref</span> ts, ..} =&gt; {
                ts.find(&amp;<span class="st">&quot;name&quot;</span>.to_string()) == <span class="kw">Some</span>(<span class="st">&quot;Ciruit de Spa Francorchamps&quot;</span>)
            }
            _ =&gt; <span class="kw">false</span>
        }
    }).next().unwrap();
    <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, expand_relation(relation, &amp;osm.elements));
}</code></pre>
<p>We get the values from the hash map; filter the iterator so it only contains relations with the right name and get the first. Note that we have to dereference <code>e</code> (the element) twice because values creates an iterator of references and filter call the closure with a reference to the element. We then pass it to <code>expand_relation</code>:</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> expand_relation(elem: &amp;OsmElement, elements: &amp;HashMap&lt;<span class="kw">int</span>, OsmElement&gt;) -&gt; Vec&lt;Vec&lt;(<span class="kw">f64</span>, <span class="kw">f64</span>)&gt;&gt; {
    <span class="kw">let</span> refs = <span class="kw">match</span> *elem {
        Relation {members: <span class="kw">ref</span> m, ..} =&gt; m,
        _ =&gt; <span class="ot">fail!</span>(<span class="st">&quot;expand_relation must be passed a relation&quot;</span>),
    };
    <span class="kw">let</span> <span class="kw">mut</span> ways = Vec::new(); 
    <span class="kw">for</span> r in refs.iter() {
        <span class="kw">match</span> elements.find(r) {
            <span class="kw">Some</span>(e@&amp;Way{..}) =&gt; ways.push(expand_way(e, elements)),
            <span class="kw">None</span> =&gt; <span class="ot">fail!</span>(<span class="st">&quot;Could not find element with id {}&quot;</span>, r),
            _ =&gt; (),
        };
    }
    ways
}

<span class="kw">fn</span> expand_way(elem: &amp;OsmElement, elements: &amp;HashMap&lt;<span class="kw">int</span>, OsmElement&gt;) -&gt; Vec&lt;(<span class="kw">f64</span>, <span class="kw">f64</span>)&gt; {
    <span class="kw">let</span> refs = <span class="kw">match</span> *elem {
        Way {nodes: <span class="kw">ref</span> ns, ..} =&gt; ns,
        _ =&gt; <span class="ot">fail!</span>(<span class="st">&quot;expand_way must be passed a way&quot;</span>)
    };
    <span class="kw">let</span> <span class="kw">mut</span> latlngs = Vec::new();
    <span class="kw">for</span> r in refs.iter() {
        <span class="kw">match</span> elements.find(r) {
            <span class="kw">Some</span>(e@&amp;Node{..}) =&gt; latlngs.push(expand_node(e)),
            <span class="kw">None</span> =&gt; <span class="ot">fail!</span>(<span class="st">&quot;Could not find element with id {}&quot;</span>, r),
            _ =&gt; ()
        }
    }
    latlngs
}

<span class="kw">fn</span> expand_node(elem: &amp;OsmElement) -&gt; (<span class="kw">f64</span>, <span class="kw">f64</span>) {
    <span class="kw">match</span> *elem {
        Node {lat: lat, lng: lng, ..} =&gt; (lat, lng),
        _ =&gt; <span class="ot">fail!</span>(<span class="st">&quot;expand_node must be passed a node&quot;</span>)
    }
}</code></pre>
<p><code>expand_relation</code> gets each member of the relation and looks it up in the hash map. If it is a way we call <code>expand_way</code> on it and add the resulting vector of tuples to the ways vector, otherwise we skip. <code>expand_way</code> looks up each of its nodes and inserts the latitude longitude pair into the <code>latlngs</code> vector.</p>
<p>There are a few things that are worth mentioning here. As <code>Some(e@&amp;Node{..})</code> shows we can match against references with <code>&amp;</code> and if you have <code>name@pat</code> then <code>name</code> will be bound to the match of <code>pat</code>. Finally notice how we have to check that the element we’ve been passed is the right one in <code>expand_node</code> even though we know it is because we checked in <code>expand_way</code>. This is why I think that <code>OsmElement</code> should store named structs so you could just pass the struct.</p>
<p>If you run this with <a href="https://github.com/mattyhall/osmxml/blob/master/spa.osm">spa.osm</a> in the current directory:</p>
<pre><code>$ cargo build
$ ./target/osmmodels</code></pre>
<p>You should get latitudes and longitudes flooding your screen. Yay!</p>
<p>Join me next time when we actually turn all this into models. If you have comments please feel free to <script type="text/javascript">
<!--
h='&#x71;&#x75;&#x69;&#x63;&#x6b;&#98;&#x65;&#x61;&#x6d;&#46;&#x6d;&#x65;&#46;&#x75;&#x6b;';a='&#64;';n='&#x6d;&#x61;&#116;&#116;&#104;&#x65;&#x77;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+'email me'+'<\/'+'a'+'>');
// -->
</script><noscript>email me (matthew at quickbeam dot me dot uk)</noscript>.</p>

            </div>
            <footer id="footer" class="row">
                Site proudly generated by
                <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            </footer>
        </div>
    </body>
</html>
