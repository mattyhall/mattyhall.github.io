<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        
          <title>Merging multiple migrations into one statement</title>
        
        <link rel="stylesheet" href="/static/style.css">
        <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
        <script src="https://use.fontawesome.com/b81c905ed1.js"></script>
    </head>
    <body>
        <div class="container">
          <div class="navbar">
    <img src="/static/pics/profile.png" width="150">
    <div class="navbar-text">
        <h1>Matthew Hall</h1>
        <ul class="nav">
            <li><a href="/">Home</a></li>
            <li><a href="/projects.html">Projects</a></li>
            <li><a href="/blog.html">Blog</a></li>
        </ul>
    </div>
</div>
<div class="rule"></div>

          
            <div class="content">
  <h1>Merging multiple migrations into one statement</h1>

  <p>Yep, I'm back with more boringly named blog posts! In this post we'll take a <code>CREATE TABLE</code> statement and a list of <code>ALTER TABLE</code> statements and turn them into a single <code>CREATE TABLE</code> statement. We'll do so with a helping hand from Haskell, Attoparsec and Lens but first an explanation of migrations. Feel free to skip.</p>
<h2>Intro</h2>
<p>For those of you familiar with web frameworks like Rails you will have heard of migrations. Most web apps have a database of some kind and as you're developing your website it is quite likely that you will need to make alterations to your tables. These are migrations - they change the schema of a table. They could be in the form of raw SQL statements or they could be in the form of a program with a special DSL for databases. This is the approach Rails uses.</p>
<p>This is great as you are developing but what about when you are deploying or when you decide to create the database from scratch? If each migration were to be run one after another it would be very slow and may be unreliable, due to the fact that a migration is basically a one time script which tend not to be maintained. What most systems do instead is to store the current schema and then load that into a frest database. As far as I can tell this could be done in one of two ways:</p>
<ol>
<li>After each migration is done ask the database for the current schema and store that.</li>
<li>Get all the migrations that have been applied and the original statement which created the table and from this generate a single statement which will create the table in its correct form.</li>
</ol>
<p>There are, as with everything in life, pros and cons to each. The first method requires you to have run all the migrations one after another at least once. This doesn't seem like too much of a problem but you would have to be careful not to misplace the file with the schema in, otherwise you have to run the migrations one after another and you have no longer solved the problem. You would also have to get the schema from the database and parse this information which may appear differently depending on what database engine you are using.</p>
<p>The main problem with the second approach is that it is not as likely to be correct. If you are getting the information straight from the horse's mouth - the working database - then, if your careful about parsing this information, you can be pretty sure you're right. Deducing the schema from the migrations is not as likely to be correct. You also have a problem in that some databases may have different syntax but this can be negated if you try and stick to syntax they can all interpret. There is a spec for SQL so you could just stick to that in your migrations.</p>
<p>I decided to have a go at building a program which followed the second method. I'm pretty sure that Rails and others use the first way but I thought that the second method was a more interesting problem to solve.</p>
<h2>Data types</h2>
<p>So the first task will be to parse the SQL statements into something we can pattern match on. Let's define some Abstract Data Types (ADTs):</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">{-# </span><span style="color:#b48ead;">LANGUAGE</span><span style="color:#c0c5ce;"> TemplateHaskell #-}
</span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Types </span><span style="color:#b48ead;">where
</span><span style="color:#b48ead;">import qualified </span><span style="color:#c0c5ce;">Data.Text </span><span style="color:#b48ead;">as </span><span style="color:#c0c5ce;">T
</span><span style="color:#b48ead;">import qualified </span><span style="color:#c0c5ce;">Data.Map </span><span style="color:#b48ead;">as </span><span style="color:#c0c5ce;">M
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Type </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">CInt
</span><span style="color:#c0c5ce;">          | </span><span style="color:#d08770;">CChar Int
</span><span style="color:#c0c5ce;">          </span><span style="color:#b48ead;">deriving</span><span style="color:#c0c5ce;"> (</span><span style="color:#a3be8c;">Show</span><span style="color:#c0c5ce;">, </span><span style="color:#a3be8c;">Eq</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Constraint </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">NotNull
</span><span style="color:#c0c5ce;">                | </span><span style="color:#d08770;">PrimaryKey
</span><span style="color:#c0c5ce;">                </span><span style="color:#b48ead;">deriving</span><span style="color:#c0c5ce;"> (</span><span style="color:#a3be8c;">Show</span><span style="color:#c0c5ce;">, </span><span style="color:#a3be8c;">Eq</span><span style="color:#c0c5ce;">)
</span></pre>
<p>First up we have the column types. For simplicity I've just picked a couple of types from the <a href="http://www.postgresql.org/docs/8.4/static/datatype.html">documentation of postgresql</a>. The <code>Char</code> type stores an integer which says how many characters the column can hold. There is also an ADT for constraints. Constraints are conditions the value for a column must satisfy. Once again I have only picked a couple to show.</p>
<p>Also note the language pragma and imports I have included. TemplateHaskell will be used for the <a href="https://hackage.haskell.org/package/lens">lens library</a>. For those of you who don't know lenses are a nice way to access data inside ADTs and change it - something that can sometimes be difficult in Haskell. <code>Data.Text</code> is imported as a replacement for <code>String</code> and a <code>Map</code> (or dictionary if you're from the Python world) to link the names of columns to the type and constraints for that column.</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">data </span><span style="color:#d08770;">Column </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">Column</span><span style="color:#c0c5ce;"> { _typ :: </span><span style="color:#d08770;">Type
</span><span style="color:#c0c5ce;">                     , _constraints :: [</span><span style="color:#d08770;">Constraint</span><span style="color:#c0c5ce;">]
</span><span style="color:#c0c5ce;">                     } </span><span style="color:#b48ead;">deriving</span><span style="color:#c0c5ce;"> (</span><span style="color:#a3be8c;">Show</span><span style="color:#c0c5ce;">, </span><span style="color:#a3be8c;">Eq</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">makeLenses &#39;&#39;</span><span style="color:#d08770;">Column
</span></pre>
<p>There's nothing too surprising in the definition of the <code>Column</code> type (a column has a type and some constraints, easy) except perhaps the lack of a column name. The reason for this is that we are going to store the columns in a <code>Map</code> where the name of the column is the key. We could have just said that a table contains a list of columns and stuck the name in the <code>Column</code> data type but this would mean you would have to search the list for the correct column when making alterations to it.</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">data </span><span style="color:#d08770;">Statement </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">Create T</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Text CreateStatement
</span><span style="color:#c0c5ce;">               | </span><span style="color:#d08770;">Alter T</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Text AlterStatement
</span><span style="color:#c0c5ce;">               </span><span style="color:#b48ead;">deriving</span><span style="color:#c0c5ce;"> (</span><span style="color:#a3be8c;">Show</span><span style="color:#c0c5ce;">, </span><span style="color:#a3be8c;">Eq</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">AlterStatement </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">RenameTable T</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Text
</span><span style="color:#c0c5ce;">                    | </span><span style="color:#d08770;">RenameColumn T</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Text T</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Text
</span><span style="color:#c0c5ce;">                    | </span><span style="color:#d08770;">AddColumn T</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Text Column
</span><span style="color:#c0c5ce;">                    | </span><span style="color:#d08770;">DropColumn T</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Text
</span><span style="color:#c0c5ce;">                    | </span><span style="color:#d08770;">ChangeColumnType T</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Text Type
</span><span style="color:#c0c5ce;">                    </span><span style="color:#b48ead;">deriving</span><span style="color:#c0c5ce;"> (</span><span style="color:#a3be8c;">Show</span><span style="color:#c0c5ce;">, </span><span style="color:#a3be8c;">Eq</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">CreateStatement </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">CreateTable</span><span style="color:#c0c5ce;"> { _cols :: </span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Map T</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Text Column
</span><span style="color:#c0c5ce;">                                   } </span><span style="color:#b48ead;">deriving</span><span style="color:#c0c5ce;"> (</span><span style="color:#a3be8c;">Show</span><span style="color:#c0c5ce;">, </span><span style="color:#a3be8c;">Eq</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">makeLenses &#39;&#39;</span><span style="color:#d08770;">CreateStatement
</span></pre>
<p>Finally we have the definitions of the statements themselves. First we say that a statement can either be a <code>Create</code> or an <code>Alter</code>. The <code>Text</code> value for these is the table they are creating or acting on. There are five kind of alter statements which are fairly self explanatory; for all but <code>RenameTable</code> the first argument to the constructor is the name of the column.</p>
<p>Slightly more interestingly is <code>CreateStatement</code>. This illustrates what I was talking about before with storing many columns as a map of the column's name to the column's type and contraints.</p>
<h2>Parsing SQL Statements</h2>
<p>To parse the SQL I will be using the <a href="http://hackage.haskell.org/package/attoparsec">Attoparsec</a> library. Another option would have been to use Parsec which may have given better error reporting as Attoparsec is aimed at efficiency. The libraries are quite similar though so it would be quite easy to change this code to use Parsec.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">{-# </span><span style="color:#b48ead;">LANGUAGE</span><span style="color:#c0c5ce;"> OverloadedStrings #-}
</span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Parser </span><span style="color:#b48ead;">where
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Prelude </span><span style="color:#b48ead;">hiding </span><span style="color:#c0c5ce;">(</span><span style="color:#8fa1b3;">takeWhile</span><span style="color:#c0c5ce;">)
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Data.Attoparsec.Text
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Control.Applicative
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Types
</span><span style="color:#b48ead;">import qualified </span><span style="color:#c0c5ce;">Data.Text </span><span style="color:#b48ead;">as </span><span style="color:#c0c5ce;">T
</span><span style="color:#b48ead;">import qualified </span><span style="color:#c0c5ce;">Data.Map </span><span style="color:#b48ead;">as </span><span style="color:#c0c5ce;">M
</span></pre>
<p>As usual first we have the imports. <code>OverloadedStrings</code> allows us to write Strings in the normal format:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">Hello world</span><span style="color:#c0c5ce;">&quot;
</span></pre>
<p>But instead of having to be of type <code>String</code> they could be of type <code>Text</code> or <code>ByteString</code>. This is sort of like if you write a number in Haskell it could be one of many types.</p>
<p>Note that <code>takeWhile</code> from Prelude is hidden as that name is also used by Attoparsec. We use the <code>Text</code> version of Attoparsec so we can parse <code>Text</code>.</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">parseTypeChar </span><span style="color:#b48ead;">:: Parser Type
</span><span style="color:#c0c5ce;">parseTypeChar = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  asciiCI &quot;</span><span style="color:#a3be8c;">CHAR</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  char &#39;</span><span style="color:#a3be8c;">(</span><span style="color:#c0c5ce;">&#39;
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  n &lt;- many1 digit
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  char &#39;</span><span style="color:#a3be8c;">)</span><span style="color:#c0c5ce;">&#39;
</span><span style="color:#c0c5ce;">  return $ </span><span style="color:#d08770;">CChar</span><span style="color:#c0c5ce;"> (read n)
</span></pre>
<p>The first thing to note is that all of the parser functions that will be shown here have the type <code>Parser a</code>, in this case <code>Parser Type</code>. The <code>Parser</code> type is provided by Attoparsec and allows us to parse <code>Text</code>, stopping if there is an error in parsing. Basically this type looks after all the error handling and other bits and pieces for us. We just have to say what we want to parse.</p>
<p>It may help to know what <code>parseTypeChar</code> is trying to match. It will try to parse a string in the form <code>CHAR(20)</code>. <code>parseTypeChar</code> starts by matching <code>&quot;CHAR&quot;</code> case-insensitively. It then matches an opening bracket with space either side. <code>many1 digit</code> matches 1 or more digits and returns them as a list which we call <code>n</code>. In this case <code>digit</code> is a parser which matches a numeric character and returns it but <code>many1</code> works with any parser you give it, for example we could do:</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">string </span><span style="color:#b48ead;">:: Parser String
</span><span style="color:#c0c5ce;">
</span><span style="color:#bf616a;">many1</span><span style="color:#c0c5ce;"> (</span><span style="color:#bf616a;">string</span><span style="color:#c0c5ce;"> &quot;</span><span style="color:#bf616a;">hi</span><span style="color:#c0c5ce;">&quot;) :: </span><span style="color:#b48ead;">Parser</span><span style="color:#c0c5ce;"> [</span><span style="color:#b48ead;">String</span><span style="color:#c0c5ce;">]
</span></pre>
<p>The function then matches a closing bracket, turns <code>n</code> into a number and returns it in a <code>CChar</code>. The <code>read</code> is neccessary because <code>digit</code> returns the digit as a <code>Char</code> and <code>many1</code> gives us back a list. In effect <code>n</code> is actually a <code>String</code> so we must use <code>read</code> to make it into an <code>Int</code>.</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">parseType </span><span style="color:#b48ead;">:: Parser Type
</span><span style="color:#c0c5ce;">parseType = (asciiCI &quot;</span><span style="color:#a3be8c;">INT</span><span style="color:#c0c5ce;">&quot; *&gt; pure </span><span style="color:#d08770;">CInt</span><span style="color:#c0c5ce;">) &lt;|&gt; parseTypeChar
</span></pre>
<p><code>parseType</code> shows parsing through the applicative interface. The <code>&lt;|&gt;</code> operator will attempt whatever is on it's left side and, if that fails, will try whatever is on it's right side. So in this case we are trying to either parse an int type or a char type. Parsing the int type is a further use of applicative - it uses <code>*&gt;</code> which evaluate it's left argument and then evaluates it's right argument and returns the right. This can be a very useful tool when parsing because it allows you to do things like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">char &#39;</span><span style="color:#a3be8c;">(</span><span style="color:#c0c5ce;">&#39; *&gt; many1 digit &lt;* char &#39;</span><span style="color:#a3be8c;">)</span><span style="color:#c0c5ce;">&#39;
</span></pre>
<p>In this case it will match a pair of opening and closing brackets with digits in between, just like <code>parseTypeChar</code>. There's no difference in functionality but it is a lot shorter. In addition note how the left part of <code>parseType</code> ends with a <code>pure</code>. <code>pure</code> is the applicative version of <code>return</code>. Because <code>*&gt;</code> works on <code>Parser</code>s we have to put any normal value we want into <code>Parser</code>. This is what <code>pure</code>/<code>return</code> do.</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">parseConstraint </span><span style="color:#b48ead;">:: Parser Constraint
</span><span style="color:#c0c5ce;">parseConstraint = (asciiCI &quot;</span><span style="color:#a3be8c;">NOT</span><span style="color:#c0c5ce;">&quot; *&gt; skipSpace *&gt; asciiCI &quot;</span><span style="color:#a3be8c;">NULL</span><span style="color:#c0c5ce;">&quot; *&gt; pure </span><span style="color:#d08770;">NotNull</span><span style="color:#c0c5ce;">) &lt;|&gt;
</span><span style="color:#c0c5ce;">                  (asciiCI &quot;</span><span style="color:#a3be8c;">PRIMARY</span><span style="color:#c0c5ce;">&quot; *&gt; skipSpace *&gt; asciiCI &quot;</span><span style="color:#a3be8c;">KEY</span><span style="color:#c0c5ce;">&quot; *&gt; pure </span><span style="color:#d08770;">PrimaryKey</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">parseConstraints </span><span style="color:#b48ead;">:: Parser</span><span style="color:#c0c5ce;"> [</span><span style="color:#b48ead;">Constraint</span><span style="color:#c0c5ce;">]
</span><span style="color:#c0c5ce;">parseConstraints = many1 (parseConstraint &lt;* skipSpace)
</span></pre>
<p>The constraints parser is quite similar. Perhaps note the fact that <code>*&gt;</code> can be changed together easily and the use of <code>many1</code> again. </p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">parseName </span><span style="color:#b48ead;">:: Parser T</span><span style="color:#c0c5ce;">.</span><span style="color:#b48ead;">Text
</span><span style="color:#c0c5ce;">parseName = takeWhile1 (</span><span style="color:#8fa1b3;">`</span><span style="color:#c0c5ce;">notElem</span><span style="color:#8fa1b3;">` </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">; </span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">parseColumn </span><span style="color:#b48ead;">:: Parser</span><span style="color:#c0c5ce;"> (</span><span style="color:#b48ead;">T</span><span style="color:#c0c5ce;">.</span><span style="color:#b48ead;">Text</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">Column</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">parseColumn = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  name &lt;- parseName
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  t &lt;- parseType
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  constraints &lt;- parseConstraints &lt;|&gt; pure </span><span style="color:#d08770;">[]
</span><span style="color:#c0c5ce;">  return (name, </span><span style="color:#d08770;">Column</span><span style="color:#c0c5ce;"> t constraints)
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">parseCreate </span><span style="color:#b48ead;">:: Parser Statement
</span><span style="color:#c0c5ce;">parseCreate = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  asciiCI &quot;</span><span style="color:#a3be8c;">CREATE TABLE</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  name &lt;- parseName
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  char &#39;</span><span style="color:#a3be8c;">(</span><span style="color:#c0c5ce;">&#39;
</span><span style="color:#c0c5ce;">  cols &lt;- sepBy (skipSpace *&gt; parseColumn &lt;* skipSpace) (char &#39;</span><span style="color:#a3be8c;">,</span><span style="color:#c0c5ce;">&#39;) 
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  char &#39;</span><span style="color:#a3be8c;">)</span><span style="color:#c0c5ce;">&#39;
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  char &#39;</span><span style="color:#a3be8c;">;</span><span style="color:#c0c5ce;">&#39; &lt;|&gt; pure &#39; &#39;
</span><span style="color:#c0c5ce;">  return $ </span><span style="color:#d08770;">Create</span><span style="color:#c0c5ce;"> name (</span><span style="color:#d08770;">CreateTable</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.fromList cols))
</span></pre>
<p>Ah. Now we get to the more interesting bit! First we have <code>parseName</code> which is used for any name in a statement. In this case we just take any characters which aren't a space or a semicolon as either of those would end the name. <code>parseColumn</code> is pretty standard - we just grab a name, some spaces and a type. We then try to get some constraints. However, not all columns will have constraints. Once again we use <code>&lt;|&gt;</code> to allow for this. If <code>parseCostraints</code> fails then we'll just give back an empty list.</p>
<p>Finally we have a parser for a full statement! <code>parseCreate</code> is pretty straight forward, except for when we grab the columns. Here we use the <code>sepBy</code> parser which matches it's first argument and then it's second, repeatedly. In this case we want to have many columns each separated by a comma. In the last line of the function we call <code>M.fromList</code>. Because parsing a column returns the name of the column and the column itself wrapped in a tuple, and because we get many columns, we can turn this into a <code>Map</code>. This will make doing things like grabbing the column named &quot;id&quot; very easy and also efficient.</p>
<p>Statements do not have to end with a semicolon, depending on the database used, hence the use of <code>&lt;|&gt;</code> like in parseColumn. You may be wondering why we used <code>pure ' '</code> and not something like <code>pure ()</code>. Although it wouldn't matter that much to us if we used the <code>()</code> version (as we're only going to throw it away anyway), <code>&lt;|&gt;</code> requires it's arguments to have the same type. As <code>char</code> has type <code>Parser Char</code> we must have the same type on the other side. </p>
<p>Let's test it out in ghci:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ghci&gt; :l </span><span style="color:#d08770;">Parser</span><span style="color:#c0c5ce;">.hs 
</span><span style="color:#c0c5ce;">...
</span><span style="color:#c0c5ce;">ghci&gt; :set -</span><span style="color:#d08770;">XOverloadedStrings
</span><span style="color:#c0c5ce;">ghci&gt; parseOnly parseCreate &quot;</span><span style="color:#a3be8c;">CREATE TABLE atbl (id INT PRIMARY KEY NOT NULL);</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#d08770;">Right</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">Create </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">atbl</span><span style="color:#c0c5ce;">&quot; (</span><span style="color:#d08770;">CreateTable</span><span style="color:#c0c5ce;"> {_cols = fromList [(&quot;</span><span style="color:#a3be8c;">id</span><span style="color:#c0c5ce;">&quot;,</span><span style="color:#d08770;">Column</span><span style="color:#c0c5ce;"> {_typ = </span><span style="color:#d08770;">CInt</span><span style="color:#c0c5ce;">, _constraints = [</span><span style="color:#d08770;">PrimaryKey</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">NotNull</span><span style="color:#c0c5ce;">]})]}))
</span><span style="color:#c0c5ce;">ghci&gt; parseOnly parseCreate &quot;</span><span style="color:#a3be8c;">CREATE TABLE atbl (id INT PRIMARY KEY NOT NULL, name CHAR(20));</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#d08770;">Right</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">Create </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">atbl</span><span style="color:#c0c5ce;">&quot; (</span><span style="color:#d08770;">CreateTable</span><span style="color:#c0c5ce;"> {_cols = fromList [(&quot;</span><span style="color:#a3be8c;">id</span><span style="color:#c0c5ce;">&quot;,</span><span style="color:#d08770;">Column</span><span style="color:#c0c5ce;"> {_typ = </span><span style="color:#d08770;">CInt</span><span style="color:#c0c5ce;">, _constraints = [</span><span style="color:#d08770;">PrimaryKey</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">NotNull</span><span style="color:#c0c5ce;">]}),(&quot;</span><span style="color:#a3be8c;">name</span><span style="color:#c0c5ce;">&quot;,</span><span style="color:#d08770;">Column</span><span style="color:#c0c5ce;"> {_typ = </span><span style="color:#d08770;">CChar 20</span><span style="color:#c0c5ce;">, _constraints = </span><span style="color:#d08770;">[]</span><span style="color:#c0c5ce;">})]}))
</span></pre>
<p>Fantastic, it works! The only complicated bit was enabling <code>OverloadedStrings</code>. As you can see the result is wrapped in a <code>Right</code>. This is one of the constructors of the <code>Either</code> type which is used to handle parse errors. <code>parseOnly</code> has type <code>Parser a -&gt; Text -&gt; Either String a</code> so if the parser succeeds the value it parsed is returned in a <code>Right</code>. If it fails then the error message is wrapped in a <code>Left</code>. We can then use a case statement or pattern match on this value and handle the error.</p>
<p>Now we just have to parse the alter statements and the parser is done. Luckily it is not too complicated and, hopefully, you'll be able to understand it without any help from me. Let's deal with the parsing of the different types of alter statements first, eg. <code>RENAME TO</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">-- parses statements like:
</span><span style="color:#65737e;">-- RENAME TO name
</span><span style="color:#8fa1b3;">parseRenameTable </span><span style="color:#b48ead;">:: Parser AlterStatement
</span><span style="color:#c0c5ce;">parseRenameTable = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  asciiCI &quot;</span><span style="color:#a3be8c;">RENAME TO</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  name &lt;- parseName
</span><span style="color:#c0c5ce;">  return $ </span><span style="color:#d08770;">RenameTable</span><span style="color:#c0c5ce;"> name
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">-- RENAME colName TO newColName
</span><span style="color:#8fa1b3;">parseRenameColumn </span><span style="color:#b48ead;">:: Parser AlterStatement
</span><span style="color:#c0c5ce;">parseRenameColumn = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  asciiCI &quot;</span><span style="color:#a3be8c;">RENAME</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  oldName &lt;- parseName
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  asciiCI &quot;</span><span style="color:#a3be8c;">TO</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  newName &lt;- parseName
</span><span style="color:#c0c5ce;">  return $ </span><span style="color:#d08770;">RenameColumn</span><span style="color:#c0c5ce;"> oldName newName
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">-- ADD col INT NOT NULL
</span><span style="color:#8fa1b3;">parseAddColumn </span><span style="color:#b48ead;">:: Parser AlterStatement
</span><span style="color:#c0c5ce;">parseAddColumn = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  asciiCI &quot;</span><span style="color:#a3be8c;">ADD</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  (name, column) &lt;- parseColumn
</span><span style="color:#c0c5ce;">  return $ </span><span style="color:#d08770;">AddColumn</span><span style="color:#c0c5ce;"> name column
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">-- DROP col
</span><span style="color:#8fa1b3;">parseDropColumn </span><span style="color:#b48ead;">:: Parser AlterStatement
</span><span style="color:#c0c5ce;">parseDropColumn = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  asciiCI &quot;</span><span style="color:#a3be8c;">DROP</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  name &lt;- parseName
</span><span style="color:#c0c5ce;">  return $ </span><span style="color:#d08770;">DropColumn</span><span style="color:#c0c5ce;"> name
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">-- col INT
</span><span style="color:#8fa1b3;">parseChangeColumnType </span><span style="color:#b48ead;">:: Parser AlterStatement
</span><span style="color:#c0c5ce;">parseChangeColumnType = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  name &lt;- parseName
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  typ &lt;- parseType
</span><span style="color:#c0c5ce;">  return $ </span><span style="color:#d08770;">ChangeColumnType</span><span style="color:#c0c5ce;"> name typ
</span></pre>
<p>And now the last pieces of the puzzle - parsing an alter statement and a helper function to change text into a <code>Statement</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">parseAlter </span><span style="color:#b48ead;">:: Parser Statement
</span><span style="color:#c0c5ce;">parseAlter =  </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  asciiCI &quot;</span><span style="color:#a3be8c;">ALTER TABLE</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  name &lt;- parseName
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  alter &lt;- parseRenameTable &lt;|&gt; parseRenameColumn &lt;|&gt; parseAddColumn &lt;|&gt; parseDropColumn &lt;|&gt; parseChangeColumnType
</span><span style="color:#c0c5ce;">  skipSpace
</span><span style="color:#c0c5ce;">  char &#39;</span><span style="color:#a3be8c;">;</span><span style="color:#c0c5ce;">&#39; &lt;|&gt; pure &#39; &#39;
</span><span style="color:#c0c5ce;">  return $ </span><span style="color:#d08770;">Alter</span><span style="color:#c0c5ce;"> name alter
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">parseStatement </span><span style="color:#b48ead;">:: T</span><span style="color:#c0c5ce;">.</span><span style="color:#b48ead;">Text -&gt; Statement
</span><span style="color:#c0c5ce;">parseStatement xs = q
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">where</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">Right</span><span style="color:#c0c5ce;"> q) = parseOnly (parseCreate &lt;|&gt; parseAlter) xs
</span></pre>
<p><code>parseAlter</code> should look fairly simple to you now. <code>parseStatement</code> is rather naughty and not good Haskell style. We use <code>parseOnly</code> like in the interactive ghci sessions but we grab the <code>Statement</code> value out of it by pattern matching. But what if the parser fails and we get a <code>Left</code>? Well the program will crash - not good. Happily one of the benefits of writing a blog post is that you can only include statements that will work so I can probably get away with matching the <code>Right</code>!</p>
<h2>Merging</h2>
<h3>State</h3>
<p>Now the good bit. That parsing was a bit of a slog but now we can actually have a go at merging statements into one. The approach I shall use is to have a <code>Map</code> of table names to <code>CrateStatement</code>s. The advantages of using <code>CreateStatement</code> is two-fold:</p>
<ol>
<li>It allows us to store and edit all the table data - column names, types, constraints. You can think of <code>CreateStatement</code> as just a representation of a <code>Table</code>.</li>
<li>We can easily create a <code>Statement</code> out of it which we will return when we've merged all the migrations.</li>
</ol>
<p>Hang on a second. &quot;store and edit&quot;. It sounds like we needs some mutable state and so we're going to store this using the State monad. It provides us with three functions:</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">-- State s a where s is the state held and a is the return type
</span><span style="color:#8fa1b3;">get </span><span style="color:#b48ead;">:: State </span><span style="color:#bf616a;">s s
</span><span style="color:#bf616a;">put</span><span style="color:#c0c5ce;"> :: </span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">-&gt; State </span><span style="color:#bf616a;">s </span><span style="color:#c0c5ce;">()
</span><span style="color:#bf616a;">modify</span><span style="color:#c0c5ce;"> :: (</span><span style="color:#bf616a;">s </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">s</span><span style="color:#c0c5ce;">) </span><span style="color:#b48ead;">-&gt; State </span><span style="color:#bf616a;">s </span><span style="color:#c0c5ce;">()
</span></pre>
<p>This is exactly the kind of thing we need. The problem is that modifying values can be a bit clunky. For example:</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">-- Given the state M.fromList [(&#39;a&#39;, M.fromList [(&#39;1&#39;, 10)]), (&#39;b&#39;, M.empty)]
</span><span style="color:#8fa1b3;">change </span><span style="color:#b48ead;">:: State</span><span style="color:#c0c5ce;"> (</span><span style="color:#b48ead;">M</span><span style="color:#c0c5ce;">.</span><span style="color:#b48ead;">Map Char</span><span style="color:#c0c5ce;"> (</span><span style="color:#b48ead;">M</span><span style="color:#c0c5ce;">.</span><span style="color:#b48ead;">Map Char Int</span><span style="color:#c0c5ce;">)) () 
</span><span style="color:#c0c5ce;">change = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    m &lt;- get
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> a) = </span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.lookup &#39;</span><span style="color:#a3be8c;">a</span><span style="color:#c0c5ce;">&#39;
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">-- inserting a value that already exists changed the associated value with the value given
</span><span style="color:#c0c5ce;">    modify (</span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.insert &#39;</span><span style="color:#a3be8c;">a</span><span style="color:#c0c5ce;">&#39; (</span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.insert &#39;</span><span style="color:#a3be8c;">1</span><span style="color:#c0c5ce;">&#39; </span><span style="color:#d08770;">100</span><span style="color:#c0c5ce;"> a))
</span></pre>
<p>As you can see when we have any kind of nesting then it gets a bit messy. Seeing as we will be storing data of the type <code>M.Map T.Text CreateStatement</code>, where <code>CreateStatement</code> has extra data, we're going to need a nicer way to do this. We shall do this with lenses.</p>
<h3>Lenses</h3>
<p>The <a href="https://hackage.haskell.org/package/lens">lens library</a>, written by Edward Kmett, provides a nice way to get and set values no matter how deeply nested they are. Lens can be quite difficult to use for beginners and I have to confess I am not exactly an expert in them myself. I do know just enough to accomplish what we are doing today though.</p>
<p>Let's quickly run through how to use lens. We'll create a data type for a description and a point:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">data </span><span style="color:#d08770;">Description </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">Description</span><span style="color:#c0c5ce;"> { _terrainType :: </span><span style="color:#d08770;">String
</span><span style="color:#c0c5ce;">                               , _town :: </span><span style="color:#d08770;">String</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">makeLenses &#39;&#39;</span><span style="color:#d08770;">Description
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Point </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">Point</span><span style="color:#c0c5ce;"> { _x :: </span><span style="color:#d08770;">Int
</span><span style="color:#c0c5ce;">                   , _y :: </span><span style="color:#d08770;">Int
</span><span style="color:#c0c5ce;">                   , _z :: </span><span style="color:#d08770;">Int
</span><span style="color:#c0c5ce;">                   , _description :: </span><span style="color:#d08770;">Description
</span><span style="color:#c0c5ce;">                   }
</span><span style="color:#c0c5ce;">makeLenses &#39;&#39;</span><span style="color:#d08770;">Point
</span></pre>
<p>The function <code>makeLenses</code> automatically generates lenses for the data type given, so each accessor (<code>_x</code>, <code>_description</code> etc) will get a lens (<code>x</code>, <code>description</code> etc). We used this when declaring <code>Column</code> and <code>Statement</code> earlier. One way to think of lenses is as a path to data - a reference. <code>x</code> is a reference from a <code>Point</code> to an <code>Int</code>. The type signature for lenses almost reads like the explanation:</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">x </span><span style="color:#b48ead;">:: Lens</span><span style="color:#c0c5ce;">&#39;            </span><span style="color:#b48ead;">Point        Int
</span><span style="color:#65737e;">--    ^                 ^           ^
</span><span style="color:#65737e;">-- this is a lens   from a Point  to an Int
</span></pre>
<p>We can now use them like so:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ghci&gt; </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> p = </span><span style="color:#d08770;">Point 10 10 10</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">Description </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">Sandy</span><span style="color:#c0c5ce;">&quot; &quot;</span><span style="color:#a3be8c;">Eastbourne</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">ghci&gt; view x p
</span><span style="color:#d08770;">10
</span><span style="color:#c0c5ce;">ghci&gt; view (description . terrainType) p
</span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">Sandy</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">ghci&gt; p ^. description . terrain
</span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">Sandy</span><span style="color:#c0c5ce;">&quot;
</span></pre>
<p><code>view</code> is a function which gives back the value pointed to by the lens (given as the first argument) in the second argument. Notice how we can compose lenses with <code>.</code> - function composition. It even reads like an OOP accessor would. Having to wrap the lens in brackets is a bit tiresome though, so there is a nice operator defined (<code>^.</code>) which is just <code>view</code> renamed.</p>
<p>We can also set values:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ghci&gt; set x </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;"> p
</span><span style="color:#d08770;">Point 0 10 10</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">Description </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">Sandy</span><span style="color:#c0c5ce;">&quot; &quot;</span><span style="color:#a3be8c;">Eastbourne</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">ghci&gt; set (description . terrainType) &quot;</span><span style="color:#a3be8c;">Muddy</span><span style="color:#c0c5ce;">&quot; p
</span><span style="color:#d08770;">Point 10 10 10</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">Description </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">Muddy</span><span style="color:#c0c5ce;">&quot; &quot;</span><span style="color:#a3be8c;">Eastbourne</span><span style="color:#c0c5ce;">&quot;)
</span></pre>
<p>You may be wondering why this is of use to us. Sure, it's nice that we can get and set the data so easily but we're still going to have to get it and put it from the <code>State</code> monad, right? Luckily we don't need to! Let's rewrite that nested <code>Map</code> example:</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">-- Given the state M.fromList [(&#39;a&#39;, M.fromList [(&#39;1&#39;, 10)]), (&#39;b&#39;, M.empty)]
</span><span style="color:#8fa1b3;">change </span><span style="color:#b48ead;">:: State</span><span style="color:#c0c5ce;"> (</span><span style="color:#b48ead;">M</span><span style="color:#c0c5ce;">.</span><span style="color:#b48ead;">Map Char</span><span style="color:#c0c5ce;"> (</span><span style="color:#b48ead;">M</span><span style="color:#c0c5ce;">.</span><span style="color:#b48ead;">Map Char Int</span><span style="color:#c0c5ce;">)) () 
</span><span style="color:#c0c5ce;">change = at &#39;</span><span style="color:#a3be8c;">a</span><span style="color:#c0c5ce;">&#39; . _Just . at &#39;</span><span style="color:#a3be8c;">1</span><span style="color:#c0c5ce;">&#39; .= </span><span style="color:#d08770;">Just 100
</span></pre>
<p>Wow, that's a lot less code! It's pretty dense though. Let's break it into chunks. </p>
<ul>
<li><code>.=</code> is like <code>set</code> only it works on the state in the <code>State</code> monad. Because it's working on the state we don't need to pass it the data structure we want to change</li>
<li><code>at 'a'</code>. The lens <code>at</code> accesses the value in containers like <code>Map</code>. Here we get the value associated with <code>'a'</code>. The problem with <code>Map</code> structures is that no value may exist for that key. For this reason <code>at</code> returns the value associated with the key given wrapped in a <code>Maybe</code>.</li>
<li><code>_Just . at '1'</code>. Before we can access the <code>Map</code> within the <code>Map</code> we have to unwrap it from it's <code>Maybe</code> coating. This is the reason for the <code>_Just</code>. We can then access the value at the key <code>'1'</code>.</li>
<li><code>Just 100</code>. Remember how <code>at</code> wraps the value it points at in a <code>Maybe</code>? Well that means we have to set it to a value which is a <code>Maybe</code>. In this case we use <code>Just 100</code>. But what if we had used <code>Nothing</code>? In that case the key and it's value is deleted from the <code>Map</code>, if it existed. Nifty!</li>
</ul>
<p>Hopefully this has piqued your interest in Lens. I have been purposefully brief as I didn't want to fall into the trap of writing a lens tutorial; I predict that lens is the new monad! Fortunately there are some great resources out there if. Take a look at <a href="http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html">Program imperatively using Haskell lenses</a> and <a href="https://www.fpcomplete.com/user/tel/a-little-lens-starter-tutorial">A Little Lens Starter Tutorial</a>.</p>
<h3>Merging statements</h3>
<p>So to recap we shall have a list of <code>Statement</code>s which will be given to a function. Each of these <code>Statement</code>s will be passed to a function which will update it's state to reflect the changes the migration asked for.</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Sql </span><span style="color:#b48ead;">where
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Types
</span><span style="color:#b48ead;">import qualified </span><span style="color:#c0c5ce;">Data.Map </span><span style="color:#b48ead;">as </span><span style="color:#c0c5ce;">M
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Control.Lens
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Control.Monad.State
</span><span style="color:#b48ead;">import qualified </span><span style="color:#c0c5ce;">Data.Text </span><span style="color:#b48ead;">as </span><span style="color:#c0c5ce;">T
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">type </span><span style="color:#d08770;">Merger</span><span style="color:#c0c5ce;"> a = </span><span style="color:#d08770;">State</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Map T</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Text CreateStatement</span><span style="color:#c0c5ce;">) a
</span><span style="color:#c0c5ce;">
</span><span style="color:#8fa1b3;">mergeMigration </span><span style="color:#b48ead;">:: Statement -&gt; Merger </span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">
</span><span style="color:#bf616a;">singleStatementFromMigrations</span><span style="color:#c0c5ce;"> :: [</span><span style="color:#b48ead;">Statement</span><span style="color:#c0c5ce;">] </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> [</span><span style="color:#b48ead;">Statement</span><span style="color:#c0c5ce;">]
</span><span style="color:#c0c5ce;">singleStatementFromMigrations statements = </span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.foldWithKey (\tblName cStatement acc -&gt; </span><span style="color:#d08770;">Create</span><span style="color:#c0c5ce;"> tblName cStatement : acc) </span><span style="color:#d08770;">[]</span><span style="color:#c0c5ce;"> m
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">where</span><span style="color:#c0c5ce;"> m = execState (mapM_ mergeMigration statements) </span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.empty
</span></pre>
<p>Here's our entry point. For each statement we apply a function called <code>mergeMigration</code> using <code>mapM_</code>. This is vary similar to the <code>map</code> function for lists only <code>mapM_</code> applies a monadic function, in this case a function with state, to each value in the list and then throws away all the values that were returned. It's important to note that the state will be retained from the last call, so if the first run of <code>mergeMigration</code> changes the state then this change will still be there on the second run.</p>
<p>We then use <code>execState</code> to run the stateful action which <code>mapM_</code> gave us with the default state of an empty <code>Map</code> and get back the final state (of type <code>M.Map T.Text CreateStatement</code>). We then fold through the map, building up a list of <code>Statement</code>s from the key of the <code>Map</code> (which is the table name) and the value (which is the <code>CreateStatement</code>). In short we'll have one create statement for each table that was created and each statement will reflect any changes made with alter statements!</p>
<p>So let's have a look at the first few bits of <code>mergeMigration</code> then:</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">mergeMigration </span><span style="color:#b48ead;">:: Statement -&gt; Merger </span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">mergeMigration (Create name ctbl) = at name .= </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> ctbl  
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">mergeMigration (</span><span style="color:#d08770;">Alter</span><span style="color:#c0c5ce;"> name (</span><span style="color:#d08770;">RenameTable</span><span style="color:#c0c5ce;"> newName)) = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    tbl &lt;- use $ at name
</span><span style="color:#c0c5ce;">    at name .= </span><span style="color:#d08770;">Nothing
</span><span style="color:#c0c5ce;">    at newName .= tbl
</span></pre>
<p>The first, and easiest, case is if we get a create statement. In this case we grab the name of the table and the <code>CreateStatement</code> which holds the information about the columns and associate the name with the <code>CreateStatement</code> in the <code>Map</code>. Remember we store the <code>CreateStatement</code> so we can build a <code>Statement</code> easily and because it already has all the data we need.</p>
<p>The next case is a bit more interesting. If we need to rename a table then we get the data we currently have on that table using the <code>use</code> function. You can think of <code>use</code> as <code>view</code> but in the state monad. We then remove the table from the <code>Map</code> by using <code>at</code> and setting it's value to <code>Nothing</code> as seen before. Finally we reinsert the table at the key <code>newName</code>.</p>
<p>Both of these cases and all of the cases I shall show could have quite easily been written without <code>State</code>. The second one would look a little like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">mergeMigration (</span><span style="color:#d08770;">Alter</span><span style="color:#c0c5ce;"> name (</span><span style="color:#d08770;">RenameTable</span><span style="color:#c0c5ce;"> newName)) m = m&#39;&#39;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">where</span><span style="color:#c0c5ce;"> tbl = m ^. at name
</span><span style="color:#c0c5ce;">          m&#39;  = set (at name) </span><span style="color:#d08770;">Nothing</span><span style="color:#c0c5ce;"> m 
</span><span style="color:#c0c5ce;">          m&#39;&#39; = set (at newName) tbl m&#39;
</span></pre>
<p>The state version looks easier to read to me but the advantage is minimal elsewhere. At any rate, we've saved ourselves some typing and what is more important that that? Certainly not readability.</p>
<p>We've now got something that we can test, so fire up ghci:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ghci&gt; :set -</span><span style="color:#d08770;">XOverloadedStrings
</span><span style="color:#c0c5ce;">ghci&gt; </span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Parser
</span><span style="color:#c0c5ce;">ghci&gt; </span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Sql
</span><span style="color:#c0c5ce;">ghci&gt; </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> stmts = map parseStatements [&quot;</span><span style="color:#a3be8c;">CREATE TABLE tbl (col1 INT);</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">ALTER TABLE tbl RENAME TO atbl</span><span style="color:#c0c5ce;">&quot;]
</span><span style="color:#c0c5ce;">ghci&gt; singleStatementFromMigrations stmnts
</span><span style="color:#c0c5ce;">[</span><span style="color:#d08770;">Create </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">atbl</span><span style="color:#c0c5ce;">&quot; (</span><span style="color:#d08770;">CreateTable</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.fromList [(&quot;</span><span style="color:#a3be8c;">col1</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#d08770;">Column Int []</span><span style="color:#c0c5ce;">)]))]
</span></pre>
<p>Magic! I'm available to book for birthday parties. :D</p>
<h3>Error handling</h3>
<p>So it works for correct input. But what about for incorrect input, for example altering a table that does not exist? In that case the magic runs out a bit:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ghci&gt; </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> stmts = map parseStatements [&quot;</span><span style="color:#a3be8c;">ALTER TABLE tbl RENAME TO atbl</span><span style="color:#c0c5ce;">&quot;]
</span><span style="color:#c0c5ce;">ghci&gt; singleStatementFromMigrations stmnts
</span><span style="color:#d08770;">[]
</span></pre>
<p>Uh-oh. Returning an empty list isn't too bad but really we should be returning an error of some kind here. Altering a table that doesn't exist is not good behaviour and failing quietly is generally a bad idea. Let's fix this!</p>
<p>In Haskell there are two basic ways to handle errors. The first is the <code>Maybe</code> type which we have already seen. A value can either be <code>Just a</code> indicating, a successful result of <code>a</code>, or <code>Nothing</code>, idicating a unsuccessful result. Although that is a bit better than what we have, it would be nice to be able to give some extra information about the error. This is where the <code>Either</code> type comes in, which has two type paramaters (ie <code>Either a b</code>). Hopefully you remember this from <code>parseOnly</code>. <code>Either</code> has two constructors:</p>
<ul>
<li><code>Left a</code>. Conventionally used to signify an unsuccessful result with information <code>a</code></li>
<li><code>Right b</code>. A successful result of <code>b</code></li>
</ul>
<p>I say conventionally because <code>Either</code> can be used for other things as well. There's one more piece of the puzzle left however. For our error handling to work we could do with stopping at the first error we encounter. Luckily <code>Either</code> can do this as well. Just like <code>Maybe</code> we can use <code>Either</code> as a monad. Consider the following:</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">test </span><span style="color:#b48ead;">:: Either String Int
</span><span style="color:#c0c5ce;">test = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  </span><span style="color:#d08770;">Right 10
</span><span style="color:#c0c5ce;">  </span><span style="color:#d08770;">Left </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">Error</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">  </span><span style="color:#d08770;">Right 20
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">ghci&gt; test
</span><span style="color:#d08770;">Left </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">Error</span><span style="color:#c0c5ce;">&quot;
</span></pre>
<p>Excellent! It turns out if we use <code>Either</code> as a monad it will stop and return (although as this is Haskell that may be a misuse of the term 'return') the first <code>Left</code> it finds. But how do we use this with the State monad? The more expirienced Haskellers amongst you may already know the answer - monad transformers.</p>
<p>A monad transformer allows us to make one monad out of multiple other monads and the one monad shares the properties of the ones it was made out of. In our case it will allow us to pass state around and do some error handling. Let's redefine <code>Merger</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">type </span><span style="color:#d08770;">Merger</span><span style="color:#c0c5ce;"> a = </span><span style="color:#d08770;">StateT</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">Map String CreateStatement</span><span style="color:#c0c5ce;">) (</span><span style="color:#d08770;">Either String</span><span style="color:#c0c5ce;">) a
</span><span style="color:#65737e;">--                           ^                              ^         ^
</span><span style="color:#65737e;">--                          state                      inner monad  return type
</span></pre>
<p>As you can tell <code>StateT</code> takes some state, a monad and a return type. You may be wondering why the inner monad is <code>Either String</code> and not just <code>Either</code>. A basic explanation is to create a monad your type must have a space for the return value <code>a</code>. If we just tried using <code>Either</code> then we have two spaces and this wouldn't work. Admittedly this is a pretty bad explanation - it is only half correct and a little simplistic. Luckily you do not have to understand completely to be able to follow along.</p>
<p>Let's rewrite the first couple of cases of mergeMigration:</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">mergeMigration </span><span style="color:#b48ead;">:: Statement -&gt; Merger </span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">mergeMigration (Create name ctbl) = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    n &lt;- use $ at name
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> n </span><span style="color:#b48ead;">of 
</span><span style="color:#c0c5ce;">        </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> _ -&gt; lift $ </span><span style="color:#d08770;">Left</span><span style="color:#c0c5ce;"> (&quot;</span><span style="color:#a3be8c;">Table &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack name ++ &quot;</span><span style="color:#a3be8c;">&#39; already created</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">        </span><span style="color:#d08770;">Nothing </span><span style="color:#c0c5ce;">-&gt; at name .= </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> ctbl  
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">mergeMigration (</span><span style="color:#d08770;">Alter</span><span style="color:#c0c5ce;"> name (</span><span style="color:#d08770;">RenameTable</span><span style="color:#c0c5ce;"> newName)) = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  tbl &lt;- use $ at name                 
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> tbl </span><span style="color:#b48ead;">of
</span><span style="color:#c0c5ce;">    </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> _  -&gt; </span><span style="color:#b48ead;">do</span><span style="color:#c0c5ce;"> at name .= </span><span style="color:#d08770;">Nothing
</span><span style="color:#c0c5ce;">                  at newName .= tbl
</span><span style="color:#c0c5ce;">    </span><span style="color:#d08770;">Nothing </span><span style="color:#c0c5ce;">-&gt; lift $ </span><span style="color:#d08770;">Left</span><span style="color:#c0c5ce;"> (&quot;</span><span style="color:#a3be8c;">Table &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack name ++ &quot;</span><span style="color:#a3be8c;">&#39; does not exist so cannot rename</span><span style="color:#c0c5ce;">&quot;)
</span></pre>
<p>In the first case we grab the <code>CreateStatement</code> associated with <code>name</code>. Because <code>at</code> will give us back a <code>Maybe</code> when we get data with it we can use a case statement. If there was no <code>name</code> in the <code>Map</code> then we can insert it as normal. If there was a value associated with that key then we create an error message in a <code>Left</code>. We then pass this <code>lift</code>. <code>lift</code> is a special function that lifts functions of the inner monad into the outer one. In this program it will take our <code>Either String a</code> and turn it into <code>StateT (M.Map String CreateStatement) (Either String) a</code>. Now to check if it works:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ghci&gt; </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> stmts = map parseStatements [&quot;</span><span style="color:#a3be8c;">ALTER TABLE tbl RENAME TO atbl</span><span style="color:#c0c5ce;">&quot;]
</span><span style="color:#c0c5ce;">ghci&gt; singleStatementFromMigrations stmnts
</span><span style="color:#d08770;">Left </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">Table &#39;tbl&#39; does not exist so cannot rename</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">ghci&gt; </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> stmts = map parseStatements [&quot;</span><span style="color:#a3be8c;">CREATE TABLE tbl (col1 INT);</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">ALTER TABLE tbl RENAME TO atbl</span><span style="color:#c0c5ce;">&quot;]
</span><span style="color:#c0c5ce;">ghci&gt; singleStatementFromMigrations stmnts
</span><span style="color:#d08770;">Right</span><span style="color:#c0c5ce;"> [</span><span style="color:#d08770;">Create </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">atbl</span><span style="color:#c0c5ce;">&quot; (</span><span style="color:#d08770;">CreateTable</span><span style="color:#c0c5ce;"> (</span><span style="color:#d08770;">M</span><span style="color:#c0c5ce;">.fromList [(&quot;</span><span style="color:#a3be8c;">col1</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#d08770;">Column Int []</span><span style="color:#c0c5ce;">)]))]
</span></pre>
<p>Error reporting works and we haven't messed anything else up.</p>
<h3>Last <code>mergeMigration</code> cases</h3>
<p>We only have four cases left!</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">mergeMigration (</span><span style="color:#d08770;">Alter</span><span style="color:#c0c5ce;"> name (</span><span style="color:#d08770;">RenameColumn</span><span style="color:#c0c5ce;"> oldCol newCol)) = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">  m &lt;- get
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> col = m ^? at name . _Just . cols . at oldCol . _Just
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> col </span><span style="color:#b48ead;">of
</span><span style="color:#c0c5ce;">    </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> _ -&gt; </span><span style="color:#b48ead;">do</span><span style="color:#c0c5ce;"> at name . _Just . cols . at oldCol .= </span><span style="color:#d08770;">Nothing
</span><span style="color:#c0c5ce;">                 at name . _Just . cols . at newCol .= col
</span><span style="color:#c0c5ce;">    </span><span style="color:#d08770;">Nothing </span><span style="color:#c0c5ce;">-&gt; lift $ </span><span style="color:#d08770;">Left</span><span style="color:#c0c5ce;"> (&quot;</span><span style="color:#a3be8c;">Column &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack oldCol ++ &quot;</span><span style="color:#a3be8c;">&#39; does not exist in table &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack name 
</span><span style="color:#c0c5ce;">                            ++ &quot;</span><span style="color:#a3be8c;">&#39; so cannot rename</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">mergeMigration (</span><span style="color:#d08770;">Alter</span><span style="color:#c0c5ce;"> name (</span><span style="color:#d08770;">AddColumn</span><span style="color:#c0c5ce;"> colName col)) = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    m &lt;- get
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> c = m ^? at name . _Just . cols . at colName . _Just
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> c </span><span style="color:#b48ead;">of
</span><span style="color:#c0c5ce;">        </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> _ -&gt; lift $ </span><span style="color:#d08770;">Left</span><span style="color:#c0c5ce;"> (&quot;</span><span style="color:#a3be8c;">Column &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack colName ++ &quot;</span><span style="color:#a3be8c;">&#39; already exists in table &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack name 
</span><span style="color:#c0c5ce;">                               ++ &quot;</span><span style="color:#a3be8c;">&#39; so cannot add</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">        </span><span style="color:#d08770;">Nothing </span><span style="color:#c0c5ce;">-&gt; at name . _Just . cols . at colName .= </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> col
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">mergeMigration (</span><span style="color:#d08770;">Alter</span><span style="color:#c0c5ce;"> name (</span><span style="color:#d08770;">DropColumn</span><span style="color:#c0c5ce;"> colName)) = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    m &lt;- get
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> c = m ^? at name . _Just . cols . at colName . _Just
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> c </span><span style="color:#b48ead;">of 
</span><span style="color:#c0c5ce;">        </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> _ -&gt; at name . _Just . cols . at colName .= </span><span style="color:#d08770;">Nothing
</span><span style="color:#c0c5ce;">        </span><span style="color:#d08770;">Nothing </span><span style="color:#c0c5ce;">-&gt; lift $ </span><span style="color:#d08770;">Left</span><span style="color:#c0c5ce;"> (&quot;</span><span style="color:#a3be8c;">Column &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack colName ++ &quot;</span><span style="color:#a3be8c;">&#39; does not exist in table &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack name 
</span><span style="color:#c0c5ce;">                                ++ &quot;</span><span style="color:#a3be8c;">&#39; so cannot drop</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">mergeMigration (</span><span style="color:#d08770;">Alter</span><span style="color:#c0c5ce;"> name (</span><span style="color:#d08770;">ChangeColumnType</span><span style="color:#c0c5ce;"> colName t)) = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    m &lt;- get
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> c = m ^? at name . _Just . cols . at colName . _Just
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">case</span><span style="color:#c0c5ce;"> c </span><span style="color:#b48ead;">of 
</span><span style="color:#c0c5ce;">        </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> _ -&gt; at name . _Just . cols . at colName . _Just . typ .= t
</span><span style="color:#c0c5ce;">        </span><span style="color:#d08770;">Nothing </span><span style="color:#c0c5ce;">-&gt; lift $ </span><span style="color:#d08770;">Left</span><span style="color:#c0c5ce;"> (&quot;</span><span style="color:#a3be8c;">Column &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack colName ++ &quot;</span><span style="color:#a3be8c;">&#39; does not exist in table &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack name 
</span><span style="color:#c0c5ce;">                                ++ &quot;</span><span style="color:#a3be8c;">&#39; so cannot change type</span><span style="color:#c0c5ce;">&quot;)
</span></pre>
<p>What's this weird <code>^?</code> thing? It looks similar to <code>^.</code> and it does actually do something very similar. It turns out <code>_Just</code> can have 0 or 1 targets which is a subset of having 0 or more targets. In lens the former is called a <code>Prism</code> and the latter a <code>Traversal</code>. If we used <code>^.</code> then we would have to combine all the results in some way. Lens does this with monoid. Unfortunately it doesn't really make sense to have a monoid instance for any of our types and because we're actually using a prism we only care about one result. <code>^?</code> grabs the first result only and puts it in a <code>Maybe</code>. There is also <code>^..</code> which would give you all the results in a list. This is kind of where my knowledge of lens runs out but there are much better explanations of lens at the links listed previously and some good information on prisms and traversals in <a href="https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms">this tutorial about lenses and Data.Aeson - a JSON library</a>.</p>
<p>Let's make sure all of this works:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">ghci&gt; </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> stmntTexts = [ &quot;</span><span style="color:#a3be8c;">CREATE TABLE tbl (col1 INT NOT NULL, col2 CHAR(20))</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">                       , &quot;</span><span style="color:#a3be8c;">ALTER TABLE tbl RENAME TO atbl</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">                       , &quot;</span><span style="color:#a3be8c;">ALTER TABLE atbl RENAME col1 TO first_col;</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">                       , &quot;</span><span style="color:#a3be8c;">ALTER TABLE atbl first_col CHAR(15)</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">                       , &quot;</span><span style="color:#a3be8c;">ALTER TABLE atbl ADD col3 INT;</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">                       , &quot;</span><span style="color:#a3be8c;">ALTER TABLE atbl ADD tmp INT;</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">                       , &quot;</span><span style="color:#a3be8c;">ALTER TABLE atbl DROP tmp;</span><span style="color:#c0c5ce;">&quot;]
</span><span style="color:#c0c5ce;">ghci&gt; print $ singleStatementFromMigrations stmnts
</span><span style="color:#d08770;">Right</span><span style="color:#c0c5ce;"> [</span><span style="color:#d08770;">Create </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">atbl</span><span style="color:#c0c5ce;">&quot; (</span><span style="color:#d08770;">CreateTable</span><span style="color:#c0c5ce;"> {_cols = fromList [(&quot;</span><span style="color:#a3be8c;">col2</span><span style="color:#c0c5ce;">&quot;,</span><span style="color:#d08770;">Column</span><span style="color:#c0c5ce;"> {_typ = </span><span style="color:#d08770;">CChar 20</span><span style="color:#c0c5ce;">, _constraints = </span><span style="color:#d08770;">[]</span><span style="color:#c0c5ce;">}),(&quot;</span><span style="color:#a3be8c;">col3</span><span style="color:#c0c5ce;">&quot;,</span><span style="color:#d08770;">Column</span><span style="color:#c0c5ce;"> {_typ = </span><span style="color:#d08770;">CInt</span><span style="color:#c0c5ce;">, _constraints = </span><span style="color:#d08770;">[]</span><span style="color:#c0c5ce;">}),(&quot;</span><span style="color:#a3be8c;">first_col</span><span style="color:#c0c5ce;">&quot;,</span><span style="color:#d08770;">Column</span><span style="color:#c0c5ce;"> {_typ = </span><span style="color:#d08770;">CChar 15</span><span style="color:#c0c5ce;">, _constraints = [</span><span style="color:#d08770;">NotNull</span><span style="color:#c0c5ce;">]})]})]
</span></pre>
<p>Great, it works! Pretty printing the statements is left as an exercise to the reader - I've already rambled on enough!</p>
<p>And that's it. The code is a bit more repetative then I would like, I considered adding a function that would remove all the <code>case</code> statements:</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">maybeM </span><span style="color:#b48ead;">::</span><span style="color:#c0c5ce;"> (</span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; Merger </span><span style="color:#c0c5ce;">()) </span><span style="color:#b48ead;">-&gt; Merger </span><span style="color:#c0c5ce;">() </span><span style="color:#b48ead;">-&gt; Merger</span><span style="color:#c0c5ce;"> (</span><span style="color:#b48ead;">Maybe </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">) </span><span style="color:#b48ead;">-&gt; Merger </span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">maybeM success failure mMaybe = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    m &lt;- mMaybe
</span><span style="color:#c0c5ce;">    maybe failure success m
</span></pre>
<p>The first argument is a function which is run if the maybe returned a <code>Just</code> value. The second argument is the action to run if it was <code>Nothing</code> and finally there is the maybe. It would have allowed us to write code like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#8fa1b3;">mergeMigration </span><span style="color:#b48ead;">:: Statement -&gt; Merger </span><span style="color:#c0c5ce;">()
</span><span style="color:#c0c5ce;">mergeMigration (Create name ctbl) = maybeM err (at name .= </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> ctbl) (use $ at name)
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">where</span><span style="color:#c0c5ce;"> err _ = lift $ </span><span style="color:#d08770;">Left</span><span style="color:#c0c5ce;"> (&quot;</span><span style="color:#a3be8c;">Table &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack name ++ &quot;</span><span style="color:#a3be8c;">&#39; already created</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">mergeMigration (</span><span style="color:#d08770;">Alter</span><span style="color:#c0c5ce;"> name (</span><span style="color:#d08770;">RenameColumn</span><span style="color:#c0c5ce;"> oldCol newCol)) = maybeM f err (get &gt;&gt;= \m -&gt; return (m ^? at name . _Just 
</span><span style="color:#c0c5ce;">                                                                                    . cols . at oldCol . _Just))
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">where</span><span style="color:#c0c5ce;"> err   = lift $ </span><span style="color:#d08770;">Left</span><span style="color:#c0c5ce;"> (&quot;</span><span style="color:#a3be8c;">Column &#39;</span><span style="color:#c0c5ce;">&quot; ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack oldCol ++ &quot;</span><span style="color:#a3be8c;">&#39; does not exist in table &#39;</span><span style="color:#c0c5ce;">&quot; 
</span><span style="color:#c0c5ce;">                                        ++ </span><span style="color:#d08770;">T</span><span style="color:#c0c5ce;">.unpack name ++ &quot;</span><span style="color:#a3be8c;">&#39; so cannot rename</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">        f col = </span><span style="color:#b48ead;">do</span><span style="color:#c0c5ce;"> at name . _Just . cols . at oldCol .= </span><span style="color:#d08770;">Nothing
</span><span style="color:#c0c5ce;">                   at name . _Just . cols . at newCol .= </span><span style="color:#d08770;">Just</span><span style="color:#c0c5ce;"> col
</span></pre>
<p>The first one is still quite readable I think but the second is a little hairy. Higher order functions can be very useful and make code brief but sometimes readability should triumph over brevity. I'm still on the fence about whether it is an improvement or not.</p>

</div>

          
        </div>
    </body>
</html>
